# Data Structures & Algorithms
##### By: Pablo Rosales
This repository contains challenges relating to Data-Structures & Algorithms.
The challenges were written primarily by Code Fellows and this README will serve as a table of contents to the individual challenges and their appropriate README's as well.

## Table of Contents
Format:
* Link to code - Link to docs

1. [reverseArray]() - [Challenge Documentation](#)
2. [arrayShift]() - [Challenge Documentation](#)
3. [arrayBinarySearch]() - [Challenge Documentation](#)
4. [Linked Lists]() - [Challenge Documentation](#)
5. [llInsertions]() - [Challenge Documentation](#)
6. [llKthFromEnd]() - [Challenge Documentation](#)
7. [ll_merge]() - [Challenge Documentation](#)
8. [Stacks & Queues]() - [Challenge Documentation](#)
9. [queueWithStacks]() - [Challenge Documentation](#)
10. [fifo animalShelter]() - [Challenge Documentation](#)
11. [multiBracketValidation]() - [Challenge Documentation](#)
12. [Trees]() - [Challenge Documentation](#)
13. [FizzBuzz]() - [Challenge Documentation](#)
14. [breadthFirstTraversal]() - [Challenge Documentation](#)
15. [getMax (Binary tree)]() - [Challenge Documentation](#)
16. [Graph](src/main/java/graph) - [Challenge Documentation](#graph)
17. [Breadth First Graph](src/main/java/graph/Graph.java) - [Challenge Documentation](#breadth-first-graph)
18. [Get Edge](src/main/java/graph/graph.java) - [Challenge Documentation](#get-edge)
19. [Depth First Preorder Traversal]() - [Challenge Documentation](#Depth-first-preorder-traversal)
20.[]() - []()

# 401 Code Challenge Documentation

### Challenge 1:

### Approach and Efficiency

### Solution
image placeholder

---
### Challenge 2:

### Approach and Efficiency

### Solution
image placeholder

---
### Challenge 3:

### Approach and Efficiency

### Solution
image placeholder

---
### Challenge 4:

### Approach and Efficiency

### Solution
image placeholder

---
### Challenge 5:

### Approach and Efficiency

### Solution
image placeholder

---
### Challenge 6:

### Approach and Efficiency

### Solution
image placeholder

---
### Challenge 7:

### Approach and Efficiency

### Solution
image placeholder

---
### Challenge 8:

### Approach and Efficiency

### Solution
image placeholder

---
### Challenge 9:

### Approach and Efficiency

### Solution
image placeholder

---
### Challenge 10:

### Approach and Efficiency

### Solution
image placeholder

---
### Challenge 11:

### Approach and Efficiency

### Solution
image placeholder

---
### Challenge 12:

### Approach and Efficiency

### Solution
image placeholder

---
### Challenge 13:

### Approach and Efficiency

### Solution
image placeholder

---
### Challenge 14:

### Approach and Efficiency

### Solution
image placeholder

---
### Challenge 15:

### Approach and Efficiency

### Solution
image placeholder

---
### Challenge 16: Graph
Implement your own Graph. The graph should be represented as an adjacency list, and should include the following methods:
1. AddNode()
    * Adds a new node to the graph
    * Takes in the value of that node
    * Returns the added node
2. AddEdge()
    * Adds a new edge between two nodes in the graph
    * Include the ability to have a “weight”
    * Takes in the two nodes to be connected by the edge
    * Both nodes should already be in the Graph
3. GetNodes()
    * Returns all of the nodes in the graph as a collection (set, list, or similar)
4. GetNeighbors()
    * Returns a collection of nodes connected to the given node
    * Takes in a given node
    * Include the weight of the connection in the returned collection
5. Size()
    * Returns the total number of nodes in the graph

### Approach & Efficiency

### Solution
image placeholder

---
### Challenge 17: Breadth First Graph
Extend your graph object with a breadth-first traversal method that accepts a starting node. Without utilizing any of the built-in methods available to your language, return a collection of nodes in the order they were visited. Display the collection.

### Approach and Efficiency

### Solution
image placeholder

---
### Challenge 18: get edge

### Approach and Efficiency

### Solution
image placeholder

---
### Challenge 19: Depth first preoder traversal

### Approach and Efficiency

### Solution
image placeholder

---
### Challenge 20:

### Approach and Efficiency

### Solution
image placeholder
